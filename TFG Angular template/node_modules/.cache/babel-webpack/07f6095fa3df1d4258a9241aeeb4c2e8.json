{"ast":null,"code":"'use strict';\n\nvar StreamReader = function StreamReader() {\n  this._queue = [];\n  this._queueSize = 0;\n  this._offset = 0;\n};\n\nStreamReader.prototype.put = function (buffer) {\n  if (!buffer || buffer.length === 0) return;\n  if (!buffer.copy) buffer = new Buffer(buffer);\n\n  this._queue.push(buffer);\n\n  this._queueSize += buffer.length;\n};\n\nStreamReader.prototype.read = function (length) {\n  if (length > this._queueSize) return null;\n  if (length === 0) return new Buffer(0);\n  this._queueSize -= length;\n  var queue = this._queue,\n      remain = length,\n      first = queue[0],\n      buffers,\n      buffer;\n\n  if (first.length >= length) {\n    if (first.length === length) {\n      return queue.shift();\n    } else {\n      buffer = first.slice(0, length);\n      queue[0] = first.slice(length);\n      return buffer;\n    }\n  }\n\n  for (var i = 0, n = queue.length; i < n; i++) {\n    if (remain < queue[i].length) break;\n    remain -= queue[i].length;\n  }\n\n  buffers = queue.splice(0, i);\n\n  if (remain > 0 && queue.length > 0) {\n    buffers.push(queue[0].slice(0, remain));\n    queue[0] = queue[0].slice(remain);\n  }\n\n  return this._concat(buffers, length);\n};\n\nStreamReader.prototype.eachByte = function (callback, context) {\n  var buffer, n, index;\n\n  while (this._queue.length > 0) {\n    buffer = this._queue[0];\n    n = buffer.length;\n\n    while (this._offset < n) {\n      index = this._offset;\n      this._offset += 1;\n      callback.call(context, buffer[index]);\n    }\n\n    this._offset = 0;\n\n    this._queue.shift();\n  }\n};\n\nStreamReader.prototype._concat = function (buffers, length) {\n  if (Buffer.concat) return Buffer.concat(buffers, length);\n  var buffer = new Buffer(length),\n      offset = 0;\n\n  for (var i = 0, n = buffers.length; i < n; i++) {\n    buffers[i].copy(buffer, offset);\n    offset += buffers[i].length;\n  }\n\n  return buffer;\n};\n\nmodule.exports = StreamReader;","map":{"version":3,"sources":["/home/juanma/Documentos/TecladoVirtual/TFG Angular template/node_modules/websocket-driver/lib/websocket/driver/stream_reader.js"],"names":["StreamReader","_queue","_queueSize","_offset","prototype","put","buffer","length","copy","Buffer","push","read","queue","remain","first","buffers","shift","slice","i","n","splice","_concat","eachByte","callback","context","index","call","concat","offset","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAG,SAAfA,YAAe,GAAW;AAC5B,OAAKC,MAAL,GAAkB,EAAlB;AACA,OAAKC,UAAL,GAAkB,CAAlB;AACA,OAAKC,OAAL,GAAkB,CAAlB;AACD,CAJD;;AAMAH,YAAY,CAACI,SAAb,CAAuBC,GAAvB,GAA6B,UAASC,MAAT,EAAiB;AAC5C,MAAI,CAACA,MAAD,IAAWA,MAAM,CAACC,MAAP,KAAkB,CAAjC,EAAoC;AACpC,MAAI,CAACD,MAAM,CAACE,IAAZ,EAAkBF,MAAM,GAAG,IAAIG,MAAJ,CAAWH,MAAX,CAAT;;AAClB,OAAKL,MAAL,CAAYS,IAAZ,CAAiBJ,MAAjB;;AACA,OAAKJ,UAAL,IAAmBI,MAAM,CAACC,MAA1B;AACD,CALD;;AAOAP,YAAY,CAACI,SAAb,CAAuBO,IAAvB,GAA8B,UAASJ,MAAT,EAAiB;AAC7C,MAAIA,MAAM,GAAG,KAAKL,UAAlB,EAA8B,OAAO,IAAP;AAC9B,MAAIK,MAAM,KAAK,CAAf,EAAkB,OAAO,IAAIE,MAAJ,CAAW,CAAX,CAAP;AAElB,OAAKP,UAAL,IAAmBK,MAAnB;AAEA,MAAIK,KAAK,GAAI,KAAKX,MAAlB;AAAA,MACIY,MAAM,GAAGN,MADb;AAAA,MAEIO,KAAK,GAAIF,KAAK,CAAC,CAAD,CAFlB;AAAA,MAGIG,OAHJ;AAAA,MAGaT,MAHb;;AAKA,MAAIQ,KAAK,CAACP,MAAN,IAAgBA,MAApB,EAA4B;AAC1B,QAAIO,KAAK,CAACP,MAAN,KAAiBA,MAArB,EAA6B;AAC3B,aAAOK,KAAK,CAACI,KAAN,EAAP;AACD,KAFD,MAEO;AACLV,MAAAA,MAAM,GAAGQ,KAAK,CAACG,KAAN,CAAY,CAAZ,EAAeV,MAAf,CAAT;AACAK,MAAAA,KAAK,CAAC,CAAD,CAAL,GAAWE,KAAK,CAACG,KAAN,CAAYV,MAAZ,CAAX;AACA,aAAOD,MAAP;AACD;AACF;;AAED,OAAK,IAAIY,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGP,KAAK,CAACL,MAA1B,EAAkCW,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,QAAIL,MAAM,GAAGD,KAAK,CAACM,CAAD,CAAL,CAASX,MAAtB,EAA8B;AAC9BM,IAAAA,MAAM,IAAID,KAAK,CAACM,CAAD,CAAL,CAASX,MAAnB;AACD;;AACDQ,EAAAA,OAAO,GAAGH,KAAK,CAACQ,MAAN,CAAa,CAAb,EAAgBF,CAAhB,CAAV;;AAEA,MAAIL,MAAM,GAAG,CAAT,IAAcD,KAAK,CAACL,MAAN,GAAe,CAAjC,EAAoC;AAClCQ,IAAAA,OAAO,CAACL,IAAR,CAAaE,KAAK,CAAC,CAAD,CAAL,CAASK,KAAT,CAAe,CAAf,EAAkBJ,MAAlB,CAAb;AACAD,IAAAA,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAL,CAASK,KAAT,CAAeJ,MAAf,CAAX;AACD;;AACD,SAAO,KAAKQ,OAAL,CAAaN,OAAb,EAAsBR,MAAtB,CAAP;AACD,CAhCD;;AAkCAP,YAAY,CAACI,SAAb,CAAuBkB,QAAvB,GAAkC,UAASC,QAAT,EAAmBC,OAAnB,EAA4B;AAC5D,MAAIlB,MAAJ,EAAYa,CAAZ,EAAeM,KAAf;;AAEA,SAAO,KAAKxB,MAAL,CAAYM,MAAZ,GAAqB,CAA5B,EAA+B;AAC7BD,IAAAA,MAAM,GAAG,KAAKL,MAAL,CAAY,CAAZ,CAAT;AACAkB,IAAAA,CAAC,GAAGb,MAAM,CAACC,MAAX;;AAEA,WAAO,KAAKJ,OAAL,GAAegB,CAAtB,EAAyB;AACvBM,MAAAA,KAAK,GAAG,KAAKtB,OAAb;AACA,WAAKA,OAAL,IAAgB,CAAhB;AACAoB,MAAAA,QAAQ,CAACG,IAAT,CAAcF,OAAd,EAAuBlB,MAAM,CAACmB,KAAD,CAA7B;AACD;;AACD,SAAKtB,OAAL,GAAe,CAAf;;AACA,SAAKF,MAAL,CAAYe,KAAZ;AACD;AACF,CAfD;;AAiBAhB,YAAY,CAACI,SAAb,CAAuBiB,OAAvB,GAAiC,UAASN,OAAT,EAAkBR,MAAlB,EAA0B;AACzD,MAAIE,MAAM,CAACkB,MAAX,EAAmB,OAAOlB,MAAM,CAACkB,MAAP,CAAcZ,OAAd,EAAuBR,MAAvB,CAAP;AAEnB,MAAID,MAAM,GAAG,IAAIG,MAAJ,CAAWF,MAAX,CAAb;AAAA,MACIqB,MAAM,GAAG,CADb;;AAGA,OAAK,IAAIV,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGJ,OAAO,CAACR,MAA5B,EAAoCW,CAAC,GAAGC,CAAxC,EAA2CD,CAAC,EAA5C,EAAgD;AAC9CH,IAAAA,OAAO,CAACG,CAAD,CAAP,CAAWV,IAAX,CAAgBF,MAAhB,EAAwBsB,MAAxB;AACAA,IAAAA,MAAM,IAAIb,OAAO,CAACG,CAAD,CAAP,CAAWX,MAArB;AACD;;AACD,SAAOD,MAAP;AACD,CAXD;;AAaAuB,MAAM,CAACC,OAAP,GAAiB9B,YAAjB","sourcesContent":["'use strict';\n\nvar StreamReader = function() {\n  this._queue     = [];\n  this._queueSize = 0;\n  this._offset    = 0;\n};\n\nStreamReader.prototype.put = function(buffer) {\n  if (!buffer || buffer.length === 0) return;\n  if (!buffer.copy) buffer = new Buffer(buffer);\n  this._queue.push(buffer);\n  this._queueSize += buffer.length;\n};\n\nStreamReader.prototype.read = function(length) {\n  if (length > this._queueSize) return null;\n  if (length === 0) return new Buffer(0);\n\n  this._queueSize -= length;\n\n  var queue  = this._queue,\n      remain = length,\n      first  = queue[0],\n      buffers, buffer;\n\n  if (first.length >= length) {\n    if (first.length === length) {\n      return queue.shift();\n    } else {\n      buffer = first.slice(0, length);\n      queue[0] = first.slice(length);\n      return buffer;\n    }\n  }\n\n  for (var i = 0, n = queue.length; i < n; i++) {\n    if (remain < queue[i].length) break;\n    remain -= queue[i].length;\n  }\n  buffers = queue.splice(0, i);\n\n  if (remain > 0 && queue.length > 0) {\n    buffers.push(queue[0].slice(0, remain));\n    queue[0] = queue[0].slice(remain);\n  }\n  return this._concat(buffers, length);\n};\n\nStreamReader.prototype.eachByte = function(callback, context) {\n  var buffer, n, index;\n\n  while (this._queue.length > 0) {\n    buffer = this._queue[0];\n    n = buffer.length;\n\n    while (this._offset < n) {\n      index = this._offset;\n      this._offset += 1;\n      callback.call(context, buffer[index]);\n    }\n    this._offset = 0;\n    this._queue.shift();\n  }\n};\n\nStreamReader.prototype._concat = function(buffers, length) {\n  if (Buffer.concat) return Buffer.concat(buffers, length);\n\n  var buffer = new Buffer(length),\n      offset = 0;\n\n  for (var i = 0, n = buffers.length; i < n; i++) {\n    buffers[i].copy(buffer, offset);\n    offset += buffers[i].length;\n  }\n  return buffer;\n};\n\nmodule.exports = StreamReader;\n"]},"metadata":{},"sourceType":"script"}