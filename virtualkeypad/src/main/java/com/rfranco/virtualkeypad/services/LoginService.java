package com.rfranco.virtualkeypad.services;

import com.rfranco.virtualkeypad.autogenerated.dtos.LoginRequest;
import com.rfranco.virtualkeypad.autogenerated.dtos.LoginResponse;
import com.rfranco.virtualkeypad.autogenerated.dtos.UserRequest;
import com.rfranco.virtualkeypad.configurations.VirtualKeypadConfiguration;
import com.rfranco.virtualkeypad.exceptions.*;
import com.rfranco.virtualkeypad.models.UserModel;
import com.rfranco.virtualkeypad.repositories.LoginRepository;
import com.rfranco.virtualkeypad.repositories.UserRepository;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.Date;

@Slf4j
@Service
public class LoginService {
    @Autowired
    private LoginRepository loginrepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private VirtualKeypadConfiguration virtualKeypadConfiguration;

    @Autowired
    private PasswordEncoder passwordEncoder;

    public void logoutUser(LoginRequest loginrequest){
        //TODO:generar el m√©todo logout (MAS TARDE)
    }

    public void registerUser(UserRequest userRequest){
        if(userRequest.getUsername().isEmpty() || userRequest.getEmail().isEmpty()){
            log.error("User name and email cannot be empty");
            throw new BadRequestException("The field userName and email cannot be empty");
        }
        if(this.userRepository.findByUserName(userRequest.getUsername()) != null
            || this.userRepository.findByEmail(userRequest.getEmail()) != null){
            log.error("User with user name {} already exist in the system",userRequest.getUsername());
            throw new ConflictException("User already exist in the system");
        }else {
            try {
                UserModel usermodel = UserModel.builder()
                        .name(userRequest.getName())
                        .lastname(userRequest.getLastname())
                        .userName(userRequest.getUsername())
                        .password(this.passwordEncoder.encode(userRequest.getPassword()))
                        .email(userRequest.getEmail())
                        .build();

                this.loginrepository.save(usermodel);
            }catch (Exception e){
                log.error("Error creating the user", e);
                throw new InternalServerException("Error creating the user");
            }
        }
    }

    public LoginResponse loginUser(LoginRequest loginrequest){
        UserModel userModel = this.userRepository.findByUserName(loginrequest.getLogin());
        if(userModel==null){
            log.error("User with login {} not found in the system",loginrequest.getLogin());
            throw new NotFoundException("User not found in the system");
        }
        LoginResponse response = new LoginResponse();
        if(this.passwordEncoder.matches(loginrequest.getPassword(), userModel.getPassword())){
            try {
                response.setLogin(userModel.getUserName());
                response.setJwt(createJWT(userModel));
                response.setId((int)userModel.getUserId());
                return response;
            }catch (Exception e){
                log.error("Error creating the login response", e);
                throw new InternalServerException("Error creating the login response");
            }
        }else{
            log.error("Incorrect password");
            throw new UnauthorizedException("Incorrect password");
        }
    }


    public String createJWT(UserModel userModel){

        String token = Jwts.builder().
                setId("userJWT")
                .setSubject(userModel.getUserName())
                .setHeaderParam("alg","HS256")
                .setHeaderParam("typ","JWT")
                .claim("userName",userModel.getUserName())
                .claim("email",userModel.getEmail())
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + this.virtualKeypadConfiguration.getJwtExpirationInMillis()))
                .signWith(SignatureAlgorithm.HS512,
                        this.virtualKeypadConfiguration.getSecretKey().getBytes()).compact();

        return "Bearer " + token;
    }
}
